[
	{
		"VestingAndStaking": "Vesting and Staking App In this example, we will be building a simple yet effective vesting application.  Defining our App The App is built on the Andromeda Chain.  The build is done on testnet using the Beta ADOs. However, these ADOs may be outside of beta by the time you’re reading this.  For this build, let us assume the following:  A web-3 project is launching their own native token.  Employees of this company get an certain amount of tokens that will be vested for 1 year.  When the vested tokens are claimed, they are automatically staked.  The company will be building the Apps for its employees.  Defining the Components Vesting component to vest the native tokens.  Staking component to stake the tokens once released from vesting.  Building the App We will be creating the App for one employee. Each employee would need a separate App for them which can be built the same way we are doing this one.   Open a new empty project in the ADO Builder and give the app an appropriate name:   Vesting Component First component we will add is the Vesting ADO:   Here we have to specify two fields:   Denom: The micro denomination of the token that will be staked. In our case, we will be using the Andromeda chain/token, so we can specify 'uandr'.  The Recipient: The address or ADO who will receive the tokens once vesting is complete. In our case, we want the tokens to go to the staking ADO whenever they are claimed from vesting, so we need to reference it. We can do that by using './' followed by the component name for the staking ADO.  By default, the staking ADO will have the name 'validator-staking-1'. If you decide to change this default name, make sure you use the correct reference here.  So far, we have instructed the vesting ADO to release the vested tokens to the staking ADO. When the these tokens are sent, we want them to be automatically staked. To do so, we will have to attach a message along with the recipient.   To do this, we select  Option 1  for the message and we specify the staking message of the Staking ADO. From the docs we can see that the message is the following:   Copy pub enum ExecuteMsg {     Stake {         validator: Option<Addr>,     }, } The message needs to be attached as base64. The web-app supports using JSON format that will be auto converted for us. Select JSON instead of base64 and paste the below JSON message into the text box:  You can find validator addresses in our testnet explorer.  Copy { stake :{ validator : andrvaloper1rrymqwre6c9m5cqltjnfpahqaj3t5qw2prqqtv }}  The vesting component is now configured and we can move on to the staking component.  Staking Component Add the Validator Staking ADO.   The default validator address defines the address to be used in case we call a staking message without a specified validator. We can use the same validator address used in our attached message.  We could have opted to not specify the validator in our attached message earlier as the staking ADO will use the default validator which is the same in our case.   Now the App is ready, go ahead and publish.   Setting Up the App Creating the Vesting Batch First thing we will do, is create the vesting batch for the employee which contains the amount of tokens to be vested and the vesting schedule to use.  Select the  Create Batch  message for the Vesting component:   This will open up the a panel where we can configure the vesting schedules:   Here we specified the following:  Lockup Duration: Amount of time where the tokens are completely locked and vesting is yet to start.   Release Amount: Amount of tokens to be released every release interval. We can use a fixed amount of tokens, or a percentage of the total amount. In this example, 5% is specified.  Release Interval: Amount of time between every release. Releases start after the lockup duration has ended. 10 min is specified here.  This means that once we publish this message, the tokens will be locked for 1 hour. Then every 10 min, 5% of the tokens will be released and can be claimed by the contract owner.  Before we publish, we need to provide the tokens that will be vested. To do so, we attach funds to the message by selecting  Add Attachment , then  Add Fund :   Here we attach 10 ANDR tokens. Now we can publish.  Transferring Ownership  The App is now set up. After 1 hour, the tokens will start to vest and will be released every 10 min to claim. When claimed, they will go to the defined recipient, who in our case is the Staking ADO and will be automatically staked for us.   Now as the company, we have successfully created the App. Both the Vesting and Staking ADOs (You can read more in docs) are set up in a way where the contract owner has all the controll over them. For example, only the contract owner is able claim tokens from the Vesting ADO, and any claimed rewards/unstaked tokens from the Staking ADO will go to the contract owner. This means that we need to transfer ownership of this App, or at least the components, to the employee we have set this up for.   You can find the steps for ownership transfer in our ADO Ownership section.  Checking the Results Once the lockup period has passed, and one release interval has been reached, we can claim some tokens from vesting and check the status of our staking ADO.  If you have transferred ownership, you will need to perform these messagses using the new owner.  From the list of modifiers for the vesting component, select the  Claim All   message. This will allow you to claim any tokens that have finished vesting:   You dont need to specify anything here and can just publish. Next, let us check if the tokens have been staked. From the list of queries for the staking ADO, select  Staked Tokens :   Then lets query our staked tokens:  By not specifying the Validator Address, the default validator will be taken.   As we can see, there are 500000uandr tokens staked which is equal to 0.5 ANDR, 5% of the 10 ANDR vested. Since we just claimed one release from the vesting, and each release is 5%, then the staked amount is correct. Now every time new tokens are done vesting, we can claim them and have them be automatically staked as we have seen.  Finally, we can claim the rewards from staking by simply calling the  Claim  message from the staking components:   Once published, any rewards from staking will be sent to your address."
	},
	{
		"NftMarketplace": "NFT Marketplace App In this guide, we will be building a simple NFT Marketplace app from scratch.   Defining our App Before we begin building the app in the ADO Builder, let's define its features and functionality. For this build, we will assume a team is looking to create a simple marketplace for an NFT collection where each NFT is sold for a fixed price.   Defining our Components To create the App we described above, we need the following components:  CW721 component to mint the NFT collection  Marketplace component to sell the NFTs  Building the App Open a new empty project in the ADO Builder and give the app an appropriate name:   Add a CW721 component and fill in the fields:   Use your connected wallet for the Minter Address field.   Next, add the marketplace component to the build. Other than the optional modules, the Marketplace ADO has two fields:  Authorized Sale Type: Allows us to define a CW20 ADO  whose tokens can be set as the purchasing token for the NFT sales. This would restrict the CW20 ADOs allowed to be set to the one defined here. In case we just select native, then we can set any CW20 as the purchasing token. Using a native token is always accepted. This will be defined later on when we configure auction parameters. So for now we select the Native option.  Modules: Allows users to add modules to the auction. For now, you do not need any modules, so you can keep it empty.  Modules are currently disabled, but will be available in our next release.  The app is now ready to be published to chain. Go ahead and publish:   Setting up the NFT Sales The app has been published to chain and is ready to be interacted with. The steps we will perform in this section are the following:  Mint the NFT collection using our CW721  Start sales on each NFT minted in the collection by sending it to the marketplace  Minting the NFT Collection The easiest way to mint the NFTs is by using our Batch Mint message that can mint several NFTs at a time. Choose the Batch Mint message from the list of execute messages for a CW721 and mint some NFTs:  Make sure that the owner of the NFTs is your address.   Once done with the first token, add another token and repeat the process until you have 3 NFTs and then publish.   Starting Sales on Each NFT In order to start a sale on an NFT, you need to send that NFT to the Marketplace component with the sale parameters attached. This is very similar to what we did to start an auction on an NFT.    Select Send NFT from the list of executes of the CW721 component. The “Recipient Address” is the Marketplace component address which can be fetched from the assets page. For the “Token/NFT Name” field, put the token Id of the NFT you want to start a sale on:   Next you have the “Custom Message” field. Since you are sending to a marketplace component, select Marketplace and then select “CW721 start sale” under “Select Message”.   Here you will have to specify the following:  If we want to use a CW20 token as the purchasing token. I will not check the box as I intend to use native.  Specify the coin denom accepted for purchasing the NFT. Since I am building on the Stargaze chain, and I want to use a native tokens as the bidding token, I will specify ustars.  The starting time of the sale. This is specified through an epoch time in milliseconds. Selecting none means the sale will start immediately after the message is published. I will use that option.  The duration of the sale in milliseconds. I want the auction to run for 2 hours. .  The price of the NFT. I will choose 100000.   Recipient which is the address to receive the funds from a succesfull NFT sale. I will select none as it will default to my address (The sender of the NFT)  Not including a start time means the sale is started immediately.   Once you publish, the first NFT is sent to the marketplace ADO where it is listed for sale for the specified price. Users are able to buy the NFTs from the marketplace which will send the funds to your address and send them the NFT.  We have succesfully set up one NFT sale. You can do the same for each minted NFT. You can also use the Multi Execute option, to set up multiple messages at a time. This would allow you to send multiple NFTs to the marketplace at a time. "
	},
	{
		"Crowdfund": "Crowdfund App In this guide, we will be building a Crowdfunding application using the Andromeda ADOs.  Defining the App Before we begin building the App in the ADO Builder, let's define its features and functionality. We will assume the following:  A user/team is looking is looking to crowdfund their project through the sale of NFTs  The funds obtained after the sale will be split to different addresses where the first address is given 80% of the funds and the second address 20%  When the crowdfunding sale ends, the funds should be automatically split to the correct destinations  Defining the Components To create the app we described above, we need the following components:  CW721 component to mint NFTs  Crowdfund component to start the crowdfund sales  Splitter component to split the funds automatically when the sale ends  The workflow of the App can be described as the following:   Build the app and publish to the chain  Mint the NFTs   Start a sale on the NFTs  End the sale which sends the funds to the splitter  Splitter receives funds and splits to the designated addresses  Building the App Open a new empty project in the ADO Builder and start by giving the App an appropriate name:   Assinging a Name to the App Now add a CW721 component to the build. One thing to keep in mind here is that the Crowdfund component needs to be the minter and owner of the NFTs in order to start a sale on the NFTs later on.   Knowing this, fill in the CW721 panel and specify the minter as the crowdfund component. As we have seen in previous builds, the minter can be referenced using either the address or the local VFS name of the component in the app.   In the panel below, I used './Crowdfund' as the Minter Address as I plan to name the crowdfund component 'Crowdfund' when I add it to the app. You can use any name as long as the name of the crowdfund component is the same:   Next, add the crowdfund component to the app. For the crowdfund, you need to specify the CW721 that will be sending the NFTs to the crowdfund component which is the CW721 component you added earlier. Again we reference it by the local VFS name:   You can check the 'Mint after sale allowed?' to be able to mint NFTs after the crowdfund sale is over.  For the Token Address, I have put './Crowdfund-Nfts' since this is the name of CW721 component in my app.    Finally, add the splitter component to the app. For the splitter, you need to specify the Recipients of the funds which will be 2 addresses of your choice. For the Recipients field, select 'Add Item' which will add the first recipient:   We specified earlier that we want to send 80% of the funds to one address and the remaining 20% to another. For the first recipient, specify 0.8 for the percentage (meaning 80%). Then insert the address you want the funds to go to in the Address field. Keep the other fields as None.  Once done, add another recipient by selecting '+ Add Item', and repeat the same steps. Make sure to specify the percentage as 0.2 for the second recipient and to specify the Address as the address you want the 20% to go to.   The App is now complete. Go ahead and publish to chain:   The App in Assets Page Interacting with the App Minting the NFTs Before you can start the sale, you need to mint some NFTs to sell. You can mint these NFTs using the Crowdfund component itself. Select 'Mint' from the list of execute messages for the Crowdfund component:  To be eligible for the crowdfund sale, the owner of the NFT needs to be the Crowdfund component.   You can keep the 'Token/NFT Owner' field empty. By default when a mint is called by the crowdfund, it assigns itself as the owner of the minted NFT.    For each NFT you want to mint, select 'Add Item' and provide the NFT data. You can mint up to 100 NFTs at a time. Mint as many as you want and then publish.  Starting the Crowdfund Sale Now that everything is in place, you can start the sale on the NFTs. Select 'Start Sale' from the list of execute messages for the crowdfund component:   The fields are the following:  Make sure to select the End Time to be in the future.  End Time: Required field that specified when the sale ends meaning users can no longer purchase NFTs for the Crowdfund. Choose any date in the future.  Max Tokens Per Wallet: An optional field that specifies the maximum amount of NFTs one address is able to purchase from the sale. Defaults to 1.   Minimum Tokens Being Sold: Required field specifying the minimum amount of tokens that need to be sold in order for the crowdfund to succeed. In case this number is not met, refunds will be issued to all the buyers and the NFTs will be burned. Choose a number less than or equal to the number of NFTs that have been minted for the sale.  Price Per Token/NFT: The amount and denomination of the funds required to purchase one NFT from the sale. I use ustars here as I am creating my app on the stargaze chain.   Start Time: The time to start the sale. Selecting None would mean the sale will start immediatly.  Recipient: You need to specify who receives the funds from the sale. In this case, you want the splitter to receive the funds to split them to the desired addresses that we have set up earlier (80/20 split). Since the splitter and crowdfund components belong to the same app, we can reference the splitter by name (You can use the contract address as well).  For the message, you want the splitter to send the funds to the addresses. We can use the 'Send' execute of the splitter to do that.   Attaching Messages to Recipients Whenever you have the option to specify a recipient as an ADO (Like in our case here), you are given the option to attach a message along with any funds that will be transfered to the ADO. This message will be either a base64 encoded message or a JSON message of one of the execute messages of the receiving ADO. Whenever the ADO receives the funds, the message is automatically called and executed (Assuming the caller has the authority to call the attached message).    For a splitter, we are interested in the Send execute messge. This execute takes the sent funds and splits them to the addresses assigned to the splitter which in our case is the 2 addresses we specified earlier with the 80 20 split . This means that every time the Crowdfund sends funds to this recipient, it will execute the Send excecute message automatically.  Make sure to attach messages to ADO recipients as most ADOs do not have a way to withdraw funds meaning sending funds without a message will cause the loss of the sent funds.   JSON Representation of the Message You can use either the JSON representation or the Base64 depending on the Message type you select from the dropdown. In my case I use the Base64.  Copy {'send':{}} As Base64:  Copy eyJzZW5kIjp7fX0= Here I reference the splitter using './splitter-1' as splitter-1 is the name of my splitter component in the app.   After you publish, the sale will start and users can start buying NFTs from the sale. Once the end time is reached, you will need to execute 'End Sale' twice, once for sending the NFTs, and another time for sending the funds."
	},
	{
		"Cw20Exchange": "CW20 Exchange If unfamiliar with building Andromda Apps on the webapp, refer to 'Building Your First App' section to learn the basics before proceeding with this guide.  In this guide, we will create a CW20 Exchange App to mint, sell, and manage CW20 tokens using the Andromeda Protocol’s web app.  Defining the App Before we begin building the App in the ADO Builder, let's define its features and functionality. We will assume the following:  A project is looking to launch a CW20 token   The project is looking to sell this CW20 token in exchange for native uandr tokens  You can also sell the CW20 tokens in exchange for another CW20 of your choice, but in this example we will be using native tokens.  Defining the Components To create the app we described above, we need the following components inside the app:  CW20 component to launch and mint CW20 tokens to be sold  Exchange ADO to enable the sale of the CW20 tokens to users  The workflow of the App can be described as the following:   Build the App with the required components and publish to chain  Mint the CW20 tokens  Start a sale on the CW20 tokens by sending them to the exchange component  Purchase some of the CW20 tokens to test the app  Let's get started Building the App Open a new blank canvas in the ADO Builder and start by giving the App an appropriate name:    The first component we need to add is the CW20 ADO. It will be used to create a CW20 token that we can put up for sale later on. As this is the first time we are using a CW20 token instead of the usual CW721, let us go though the fields that can be configured:  Token Name: The name of the token. Choose any name that you want.   Token Symbol: The symbol of the tokens. Choose any symbol that you want (Between 3 and 12 characters).  Number of Decimals: The number of decimals to assign for the token. We will be using 0 in this example. To learn more about decimals, check our documentation on CW20.  Starting Balance: Initial balances to assign to specific addresses. We will not add any in this example as we will be minting the CW20 tokens after publishing the app.  Marketing Info: All the information about the token such as descriptions, logo, and URLs pointing to additional information about the project. We will not need to fill this information as this is just an example guide.  Mint: An optional address to be assigned as a minter to the ADO along with a cap. If the minter is specified, then the minter address is the only address allowed to mint/create additional CW20 tokens other than the initial balances.   Cap: If a cap is specified, then the minter can only mint an amount of new tokens so that the total amount of CW20 tokens dont exceed the cap. For example, if the cap is 1000, and the initial balances contain 800 tokens, then the minter is allowed to mint 200 tokens still.  Omiting a minter means that no additional CW20 tokens other than the initial balances can ever be created.   For this example, use your connected wallet address as the minter and there is no need for a cap.   You can rename this ADO. For this guide we will use `cw20-token`. This name will be referenced later on.   Now that we have set up our CW20, it is time to add our CW20 exchange ADO. Add a new component and select the CW20 exchange from the list of ADOs. For the exchange we just need to specify one field:  Token Address: A reference to the CW20 ADO that you are looking to sell tokens of. In our case, that is the CW20 we just set up before this. Using our VFS naming we can reference it by the assigned name. From the dropdown, choose the reference to the CW20 component.   You can rename this ADO to be referenced by the new name.  You can also reference a CW20 by the contract address if it already exists.    To publish the app, hit the 'Publish' button. A transaction simulation, then gas estimate will appear. Broadcast:     Approve the transaction:    Interacting with our App Minting the Tokens Our app is now published on the Andromeda chain, and we can start interacting with it. First step will be minting some CW20 tokens to be sold in the exchange:  - Go to your ASSETS page.  - Locate and open the App that you just created.  - Locate the CW20 component.  - Click the 3 dots to reveal a dropdown menu containing the available execute messages.  - From the dropdown menu, select “Mint.”     For our Mint message, we need to define the amount of tokens to mint and the address to receive these tokens. For this example, let us mint 10000 tokens. As for the Recipient of these tokens, we will use the our address. The exchange ADO only accepts tokens that are sent from the contract owner, which in our case will be our address:   Publish the message to the chain. In previous guides, we did not use many queries, so let us change that in this example by querying the amount of tokens the our address has and confirming that the mint was succesfull. To perform the query, we need to do the following:   - Go to your assets page.  - Locate and open the App that you just created.  - Locate the CW20 component.  - Click the 3 lines 'hamburger menu' to reveal a dropdown menu.  - From the dropdown menu, select “Balance”   - For the Address, specify the address of your App component, and press 'Query':    As we can see in the 'Query Response' section, the balance is 10000 which is the amount we minted.  Sending the Tokens to the Exchange We have created the app, minted the tokens, and checked our balance. The last step will be sending the tokens to the exchange to be sold. Similar to sending NFTs to an auction or marketplace (As seen in previous guides), we want to send the tokens to the exchange and attach the sale parameters to it.   Select the Send execute message from the list of messages available for the CW20 component. The fields here will be the following:   The contract address of the exchange ADO for the Receiving Contract Address as we are looking to send it the tokens.  10000 for the Amount Being Sent so we can sell all the tokens we minted.  For supporting messages, select CW20 Exchange and a StartSale from the drop downs. This will expand the panel and allow us to set up the sale.   As an Asset, we had discussed that we want to sell the CW20s in exchange for native tokens. So select native and uandr as the denomination .  In case you are using another chain to build this app (Not Andromeda), specify the micro-denom of that chain and not uandr.  86400000 for duration to specify the duration of the sale as one day as 86400000 ms = 1day.  As Exchange Rate, I will use 10. This means 10uandr will buy a user 1 CW20. This can be set up to whatever the project owners want.  Keep Start Time empty to start the sale immidiately.   Finally, the Recipient is the address that will receive the uandr funds that were used the buy the CW20 tokens. We want the proceeds of the sale to go to us, so specify your connected wallet address.    After publishing the message to the chain, the sale is now live and users can use the exchange ADO to to buy the CW20s using uandr funds. As a last step, we will try buying some CW20 tokens and checking the results.   You can query the balances of your address and the CW20-Exchange ADO. Your address should have 0 tokens and the exchange the 10000 as we sent all the tokens.  Testing our App To purchase some tokens, we will need to execute a message on the exchange component. From the list of execute messages, select the Purchase option:    There is only one optional field for a Purchase message which is the recipient of the CW20 tokens. This allows a user to buy the CW20 tokens for another address. For this example we want to purchase for ourselves so we do not need to specify this as it defaults to the executing wallet:   Attaching Funds to the Message Since we are using native tokens to buy the CW20s, we need to attach the native uandr funds to the message before publishing. We can do that by selecting Add Attachment  and choosing the Add Fund option. Let us buy 100 CW20 tokens. Based on our exchange rate, we would need to attach 1000uandr as each CW20 costs 10uandr:   Once added, a new panel will pop up were we can specify the type and amount of funds we want to attach:   Publish the message and let us take a look at our CW20 balance. We can use the same query we had used before, but this time we want the balance for our address (Your connected address) so specify that:   As you can see, my CW20 balance is now 100, the amount we purchsed and the uandr funds have been transferred to my address. "
	},
	{
		"AuctionUsingCw20Tokens": "Auction Using CW20 Tokens In an earlier example, we created an Auction application that takes CW721 tokens (NFTs) and creates custom auctions for each NFT.  For bidding, we had used native tokens. In this guide, we will be using CW20 tokens as the bidding token for the NFTs instead. Lets get started!  If you havent built any Apps yet, it is recommended you go through the first 3 to learn the basics.  Defining our App Before we begin building the app in the ADO Builder, let's define its features and functionality. For this build, we will assume:   A team is looking to create a private auction on their new NFT collection.  The team only wants holders of their CW20 token to be able to bid in the auction.  Defining our Components To create the App we described above, we need the following components:  CW721 component to mint the NFT collection.  Auction component to host he NFT auctions  CW20 component to create the CW20 token used in bidding.  Building the App Open a new empty project in the ADO Builder and give the app an appropriate name:   CW721 Setup Let us set up our NFTs. Add a CW721 component and fill in the fields:  Make sure to specify the minter address as your connected address to be able to mint NFTs without having to change your wallet.   CW20 Setup We also need to create a CW20 token. So add a CW20 component and customize it as you see fit:   For Starting balances, I will giving 3 of my addresses 1000 tokens to use for bidding:   Auction Setup Our last component will be the Auction component. Add one to the build and let us take a look:   Here we need to define the following:  -Authorized CW721 Addresses: The CW721 ADOs allowed to create auctions in the Auction component. We will specify the CW721 component by referencing its assigned name:   -Authorized Sales Type: Whether to allow CW20 tokens to be used as bidding tokens. Since we want to use CW20s as the bidding token, select CW20. We then need to specify the CW20 ADO that can be set as the bidding token. We want to authorize our CW20 component, so we reference it by its assigned name:   Now that all the component have been set up, we can go ahead and publish to chain:   Minting the NFTs Before we can start any auctions, we need to create the NFTs to be auctioned. Select the Mint message from the CW721 component and fill in the information for your NFT, then publish to chain:  If you are intereseted in setting up the NFT metadata (Token Identifier), you can check out the 'Setting Up NFT Metadata' section.  Feel free to use the Batch Mint execute to mint several NFTs in one go.   To make sure the NFT minted successfuly, let us query the CW721 component for the number of minted NFTs it has. Select the Num Tokens query for the CW721 and then press Query to get the number of NFTs this CW721 has created. I minted one NFT, so the result should return 1:   Customizing the NFT Auction Now that we have our NFT minted, we need to send it to the Auction component and specify the auction options. To do so, we will use the Send NFT execute message from the CW721 component:  If you have more than 1 NFT, you could use the multi-execute to send several NFTs to the auction component in one go.   Here we specify:  The Recipient address can be referenced by the contract address (found in assets page) or by referencing its assigned name.  Recipient Address: The address to receive the NFT we are sending. In our case, we want the auction component to receive the NFT so we specify that.  Token Id: The Id of the token we are sending. In my case I assigned the NFT an Id of '1' (As seen in the minting section).  Next, we need to add a custom message that contains the auction parameters. Select Custom Message and Auction from the dropdown options. Then for 'Select Message', choose 'cw721-start-auction':   For the Auction options, we specify the following:  Uses CW20: Whether the auction will use a CW20 token for bids. Since that is our goal, check the box.  When using native tokens, you specify the denomination like uandr, ustars etc... When using CW20 tokens, you specify the contract address of the CW20 ADO.  Coin Denomination: The contract address of the CW20 component.  We can get it from the assets page.  Auction Start Time: Specifiest the date and time the auction will start meaning users can start bidding. Selecting the None option means the auction will start as soon as the NFT is sent to auction.  End Time: The date and time that the auction concludes, meaning noone can place any bids anymore.  Minimum Bid: The minimum amount of tokens that can be used to bid. I will use 250 for this example.  Recipient: The receiver of the funds for a successful auction on the NFT. Selection the None option means the funds will go to the address that started the auction.  Whitelist: A list of addresses that are allowed to bid on the NFT. Selecting none means that anyone is able to bid.  Now that all the auction options have been set up, let us publish the message.   Bidding on the NFT Now that the NFT auction has been set up and published to the chain, we can start bidding on the NFT. For this, I will use the 3 addresses that I had used as recipients for my cw20 tokens.   Bidding on the NFT is usually done through the front-end interface of your application like our embeddables. For this example I will not show the steps of bidding.  Place a bid of 500 https://explorer.testnet.andromedaprotocol.io/galileo-4/tx/07F66789C5BFD35FBABF6833A34B176DA190A7198901D8C3B4413DBC8D02B1C6 explorer.testnet.andromedaprotocol.io Checking the Auction's bids using the Auction State Query:  Using the Auction State query from the list of queries for the auction component, we can check the current auction information for our NFT auction:  The auction Id is 1 here since this is the first auction that was held by the auction component. If we send another NFT to auction, then it would have an Auction Id of 2 and so on.   As we can see the 'high_bidder_amount' is currently 500. The address of the highest bidder is dispayed above it.  Placing a bid of 750  A new user places a bid of 750 tokens:  https://explorer.testnet.andromedaprotocol.io/galileo-4/tx/07EC983322E638F2CC339E0532684AEDEC328E83D4D42F6E9A9D750857903E2F explorer.testnet.andromedaprotocol.io Auction State:   The 750 is now the highest bid, and thus if the auction concludes, the user that placed the bid will receive the NFT. The bidding can continue until the end time of the auction is reached.   Checking the Results Before the Auction Concludes Before the auction ends, let us check a few things. First, the CW20 balance of the address that put the NFT up for auction. We can do this by using the Balance query for the CW20 component:   Next check the owner of the NFT we have up for sale:  The current owner of the NFT is the Auction component.   Checking the Results After the Auction Concludes After the auction ends (End time is reached), let us check the balance and NFT owner again. Before we can do that, we need to perform the Claim execute message to claim the NFT and send the funds to the seller:    Balance of the NFT Seller  After executing the Claim message, the CW20 tokens should be in the seller's balance. Let us check by performing the Balance query in our CW20 component:   As we can see, the 750 tokens are now with the NFT seller.  Owner of the Sold NFT  Let us check who owns the NFT:   As we can see, the owner is the same address that bid the 750 CW20 tokens."
	},
	{
		"ExtendedMarketplace": "Extended Marketplace In a previous example, we built a simple NFT marketplace that can be used to sell an NFT collection for  native funds. In this guide, we will be extending that build to include some of the cool features that can be used in the aOS.   Defining our App The App will be built on the Andromeda chain.  The NFTs will be sold for ANDR tokens.  For this build, let us assume the following:  There are three individuals who work in an art collective and they've been selected to work in creating a small project.  Each individual will be creating an art piece (NFT) under a theme and submitting it to be sold in the marketplace. The proceeds of these NFTs will go to each of the artists respectively.  There will be one collaborative piece that they would be working together and present as a final NFT. The proceeds from this NFT will be sent to a splitter to be evenly split between the three artists.  One of the three artists will be administrating the marketplace (minting the NFTs and sending them to the marketplace). The other two will be given a one time permission to mint an NFT.  A 5% additive tax (added to the price) will be taken from the sold NFTs for administrative costs  Defining the Components To create the App we described above, we need the following components:  CW721 component to mint the NFT collection and set up the permissions.  Marketplace component to sell the NFTs and add the taxes.   Splitter component to automatically split the funds from the collaborative NFT to the three artists.  Building the App Open a new empty project in the ADO Builder and give the app an appropriate name:   Add a CW721 component and fill in the fields:   Use your connected wallet for the Minter Address field.  I use the name 'Snail Collection' as this will be the theme for the NFTs.   Next, we need to add the marketplace component:   Here we specify the CW721 and CW20 addresses allowed to interact with our marketplace. For CW721 we specify the NFT component of our App. For CW20, we can keep it empty, as we will be using native funds to sell the NFTs.   In case you are looking to sell the NFTs for CW20 tokens, then Authorized CW20 addresses must be set.   Finally we add our splitter component:   We are assuming that one of the artists is us, so specify the connected address as one of the recipients.  We can specify None for the rest of the options.   Here we specify:  Lock Time: A lock time of 30 days is specified. This ensures that the split used by the splitter (even distribution to the 3 artists) cannot be maliciously changed by the owner until the sale is over.  Recipients: The percentage and address for each recipient. For each percentage, we use 0.33 to specify 33% and we specify the address of the artist. Add 3 recipients in total.  The app is now ready to be published to chain. Go ahead and publish:   Setting Up the App First thing we will do is set up our rates (Tax) and permissions for our application. As this is the first time we cover these features, let us quickly go over what they entail:  Rates: Allow the owner to set a fee (tax or royalty) on a specific action (execute message) in an ADO. In our case, we will add a 5% tax on buying an NFT from the marketplace.  Permissions: Allow the owner to set restrictions  (blacklist, whitelist or limited uses) for certain addresses on specific ADO actions (execute messages). In our case, we will be permissioning the 2 artists to mint an NFT from the CW721. This action was previously exclusive to the specified minter, but with permissions, we can bypass this.   Setting Rates Not all actions can be bypassed. Contract Owner resticted messages cannot be permissioned.  To set up the 5% tax on the NFT sales, select the Rates message from the list of modifiers for the marketplace component:   This will open up the following panel:   Here we select/specify the following:  Set Rate: This indicates we are adding a rate to the ADO.  The action is case sensitive.  You can also set up the rates in a seperate rates ADO and then select 'Contract' in the panel options and reference the rates ADO by contract address or VFS path.  Action: The action is the execute message we want the rates to be applied to. In the marketplace, we want the tax to be payed when the user is buying the NFT from the marketplace, so we specify it as 'Buy'. Now every time a user calls the 'Buy' modifier, they will need to pay the 5% added tax on top of the price.  Local: Indicates that the rate will be specified from the ADO itself.   Description: A small description for the rates.  Rate Type: Whether the rate should be added on top of the price (tax payed by the buyer) or should be deducted from the price (royalty paid by the seller). In our case we want it to be additive.  There could be multiple addresses to receive rates. If you specify 3 addresses, and the rate is 5%, then each of the 3 addresses would receive 5% for a total of 15%  (It is not divided between the 3).  Recipients: The addresses to receive this rate. We specify the address of the entity taking the tax. In our case, an address representing the art gallery that is hosting this project.  Percent is specified as a decimal. 0.01= 1%, 1=100% .  Value: Specifies if the rate should be a percentage of the price or a flat amount. In our case we want a 5% rate so we select 'Percent' and input 0.05 .  Once done, the panel should look something like this:    Once you publish, the rates have been successfully applied.   Setting Permissions Now we need to give the 2 artists permission to mint an NFT. In the CW721 modifiers, select 'Permissioning':   Set the permission on the action and publish:  In case of a whitelist (instead of a limited permission), you would need to call PermissionAction prior to setting the whitelist.   You can now add multiple actors at a time. This was not possible at the time of making this guide. You could permission both artists in one go by clicking add item under actor.   Action is case sensitive.  Action: The execute message we are setting a permission on. In our case it is minting an NFT so we specify as 'Mint'.  Actor: The address we are assigning the permission to. In our case, specify the address of the first artitst.  You can also set up the permissions in a seperate Address List ADO and then select 'Contract' in the panel options and reference the Address List ADO by contract address or VFS path.  It is recommended to use addresses that are yours to be able to test minting the NFTs from all the addresses later on.   Local:  Indicates that the permission will be specified from the ADO itself.   Limited: Indicates the permission will be set for a number of uses. Blacklist and whitelist can also be set as permission types. For our case, limited makes sense as we want to permission the artists to call the Mint function one time.   Expiration: If there should be an expiration for the permission. For example I can whitelist an address for 1 week and after it expires, the permission will be removed automatically. We will not include one in our example.  Uses: The number of times the permissioned actor is able to called the action. In our case we want it to be once.  Publish and then repeat the same thing (from step 2) to permission the second artist by specifying them as the actor this time.   Minting the NFTs We can now start he minting process for the NFTs. First let us start with our NFT (administrator). Go to the CW721 modifiers, and select Mint from the list of NFTs:   I have already set up 4 NFTs on Pinata to be used as the Token Identifier for each NFT. You can learn how to set up your own nfts here. You can also choose to use the same NFTs as me.  Admin NFT: https://gateway.pinata.cloud/ipfs/QmNj9dWRQVqBmNyvHbJBQsX1UrpCSUiq7REcFZ5seD9Xuj  Artist 2 NFT: https://gateway.pinata.cloud/ipfs/QmXU5gjwv4juYRvMg7o7JsHKNja7dWdx5nRhiiKXjcMcLa  Artist 3 NFT: https://gateway.pinata.cloud/ipfs/QmTkLygY8EWYArrnLPLR2zsfECDGNDU3Yb79PkjuS9UZ6Z  Collaborative NFT: https://gateway.pinata.cloud/ipfs/QmZdrhbNUF8bh2CjwU3MKCsd9gTejwMDjUDdbZh9K3GNbd   We are minting the collaborative NFT next as it will be minted by the same address that minted the first NFT (Admin).  Next, mint the collaborative NFT. Make sure to change the token Id and the Token Identifier.   For the last 2 NFTs, they will be minted by artist 2 and 3 respectively. Since artists 2 and 3 will not have the App in their assets, we need to share the asset page for the CW721 with them. We can do this by copying the url of the CW721 asset page and sharing it with the each artist:  Since this is just an example build, and artist 2 and 3 are just your addresses, you can go to the CW721 asset page and switch wallets.    Once you switch your wallet you will notice an 'External ADO' label next to the name indicating that the connected address is not the owner of this ADO:   Now we can mint the NFT as usual:   After minting the NFTs for artist-2 and artist-3 (Using their wallets), let us connect back to the admin wallet to start configuring the NFT sales.  Sending the NFTs to Marketplace As we have seen in the first marketplace guide, we need to send the NFTs from the CW721 component to the marketplace component with the needed configuration in order to start a sale on the NFT.  Select Send NFT from the list of modifiers for the CW721:    You can also use the VFS path to specify the recipient.  Recipient: The address to receive the NFT. In our case, we need to send it to the marketplace, so use that address (You can get from the asset page).   Token Id: The token Id of the NFT we are sending. Use the token Id of the NFT minted by the connected wallet.  For supporting messages, select marketplace, then the version of your marketplace component (usually the latest versin), then cw721-start-sale. Specify the sale options for the NFTs :    Here is a quick rundown of the options I have selected:  Coin Denom: uandr meaning the NFT is purchased using uandr tokens  Start Time: None meaning the sale will start as soon as the NFT is sent. You can chose to have it start at a later date.  Duration: 604800000 which is 1 week in milliseconds.  Price: 2000000 which is 2000000uandr or 2 ANDR.   Recipient: The address of the first artist (admin). This means that the proceeds from this NFT sale will go to that address.  For the NFTs of artist-2 and artist-3, use the same method used for executing the mint on the CW721 which is switching wallets on the CW721 asset page and then going through the same process we did above. Make sure to specify their addresses respectively as the recipient.  Lastly, we need to send the collaborative NFT to the marketplace. Here, instead of specifying the Recipient address as one of the artists, the recipient will be the splitter which will receive the funds from the NFT sale and split it according to the split we gave it at instantiation (33% for each artist):  The last percent will go back to the owner of the splitter which is the admin in our case.   We specify the msg in JSON format which will be converted to base64 automatically.  The msg specifies the execute message to be called on the Recipient (Splitter in our case) when the funds are sent to it. As seen in the splitter docs, a Send  execute message is used to split any sent funds by the splitter. This means that in the above configuration, we are telling the marketplace to send the proceeds of the sale to the splitter, and trigger a Send message automatically splitting the funds to our three artists.  Connecting to the Embeddable Now that the NFTs are minted, and the sales have been set up, it is time to connect our application to an embeddable. Go to the embeddables section in the web-app and select '+New Embeddable':  Add a name and description for your embeddable.   Make sure to use uandr as the coin denom.   Component addresses can be found in the assets page.  Next, select '+Add Collection', and add a marketplace collection. Fill it in with the required info:   You can select preview before publishing to preview how the page will look like. Once satisfied, publish the embeddable:   Select the three dots and then 'view'. This will take you to the embeddable asset page:   Here you can find information about the deployed embeddable and most importantly the Deployment URL. This URL can then be shared with your audience, users and they can start buying the NFTs.   Let us take a look at our embeddable:   We can explore the collection:  All of the NFTs are live for sale as we specified in our configurations for the sale.  You can select one of the NFTs and view the traits for it:   These traits were set up in the JSON files on pinata.   "
	},
	{
		"CommissionBasedSales": "Commission Based Sales Application In this example, we will be looking to set up a scaling commission sales application using the aOS.   Defining our App The App is built on the Andromeda chain.  For this build, let us assume the following:  A company that sells tickets to events wants to use web-3. These tickets are represented as NFTs.   The company employs salesmen that are tasked on getting customers and selling them the tickets.  The salesmen get a % commision on the total amount of tickets sold each month.  The commision is not fixed and varies depending on the amount of funds raised by the salesman.   The commission is scheduled to be paid at the end of each month.  The commission percentages taken by the salesman are the following:  10% if total sales is less than 10 ANDR  15% if total sales is between 10 and 30 ANDR  20% if total sales is between 30 and 100 ANDR  25% if total sales exceecd 100 ANDR  The product that is being sold can be anything the user wants. In this example we are taking the case of tickets.  The commission can also be distributed daily, weekly, or whatever the user wants. In this example we using monthly.  In this example we will focus more on building the workflow of the App rather than the NFT sales themselves. You can check other examples that go through the entire NFT setup process (NFT metadata and embeddable setup)  Defining the Components To create the App we described above, we need the following components:  CW721 component to mint the NFT collection.  Marketplace component to sell the NFTs.   Timelock component to accumulate the funds from sales throughout the month  Conditional Splitter to apply the commission split based on total amount raised.   Component Workflow As we have many components in this build, let us describe the workflow for our App to function as intended. These are the steps that we will need to do after App creation:   We will be going  through the entire build step by step.  Mint the NFTs from the CW721.  Send the NFTs to the marketplace where they can be sold.  Make the Recipient of the marketplace sales the timelock ADO and attach a message telling it to lock the funds for the end of the month.  Make the Recipient of the timelocked funds the conditional splitter and attach a message telling it to split the funds sent according to the set conditonal splits .   At the end of the month, the funds can be released in one go from the timelock to the conditional splitter which will in turn automatically split and sent the commission to the salesman, and the rest of the funds to the company.  Building the App Open a new empty project in the ADO Builder and give the app an appropriate name:   Add a CW721 component and fill in the fields:    Use your connected wallet for the Minter Address field.   Next, we need to add the Marketplace component:   Here we specify native, as we want the sales to be conducted in native uandr tokens. We aslo specify the 'Authorized Token Addresses' as our CW721 component (by its VFS reference), meaning it is the only CW721 allowed to send NFTs to our marketplace.  Next, we can add our Timelock component:   Finally, we need to add the Conditional Splitter component:   For multiple salesmen, you would need to add a Conditional Splitter for each one. In this example we will go through the setup for a single salesman.  Here we need to configure the Conditional Splitter according to the commissions we have decided in the App definiton. This can be done by defining the Threshold field. Select 'Add item':   There are two main fields needed for each commission tier:  You can also add an optional Lock Time which makes the recipient list locked (Cannot be changed from the initial declared values by anyone) for the defined time.  Recipients and Percentages: The addresses to forward funds to from the conditional splitter. In our case we will have two recipients, the salesman and the company. We will also define the percentage split for each address.    Minimum Amount: Defines the minimum amount of funds required for the above Recipients and Percentages to be activated. This will be based on the sales thresholds we defined in our App Definition.  Based on our commission splits, we need to define 4 Thresholds in total. For each, we specify the same addresses as the recipients (one for salesman and one for the company) but change the Percentage and Minimum Amount fields.  Here is what it would look like:  Use your own addresses to represent the salesman and company.  You can zoom in to view the panels in detail.   The amounts are specified in uandr (1000000 uandr = 1 ANDR).  Conditional Splitter Panels  The App is now ready for publishing.  If your App is not publishing you can reference this flex file to make sure the setup is correct  3KB app-Commission Based Sales App-staging.flex Setting Up the App Mint the NFTs The first step will be minting the NFTs that represent the tickets. For this example build, 3 NFTs will be minted. We can use the Batch Mint message from the CW721 modifier list to mint the 3 NFTs in one go:  We will not setup the NFT metadata in this example, refer to other guides if you are interested in the process.    Use your connected address as the owner to be able to send the NFTs to marketplace in the next phase.  Make sure to change the Token Id for each NFT as it needs to be unique.  Select Add Item and add 2 more NFTs and then publish.  994B cw721_2.0.1_batch-mint Send NFTs to Marketplace As we have seen in other  guides, we need to send the NFTs from the CW721 component to the marketplace component with the desired configuration for the sale.   Select Send NFT from the list of modifiers for the CW721:  You can use our 'Multi Execute' option to send all the NFTs in one go.   For the Recipient, specify the address of the Marketplace ADO in your App. Then, select the Marketplace 'CW721 start sale' and specify the NFT sale parameters:  You also need to specify the version of the marketplace you are sending to. Make sure to use the same version of your marketplace component. If not sure, you can check the version in the assets page.   We need the funds from the sales to go to the Timelock component to be locked till the end of the month. To do this, we specify the Recipient as the Timelock address.  For the msg, we want the Timelock ADO to automatically lock the funds when received. This can be done using the HoldFunds execute message for the timelock.   Let us take a look on the HoldFunds message:  You can find more detailed documentation on the Timelock ADO in our developer docs.  Copy pub enum ExecuteMsg {     HoldFunds {         condition: Option<EscrowCondition>,         recipient: Option<Recipient>,     }, } There are two fields that need to be specified:  Condition: The condition that needs to be satisfied in order for the funds to be unlocked. In our case, the condition needs to be reaching the end of the month.  Recipient: The address to receive the funds from the Timelock when they are claimed after the condition has been satisfied. In our case, we need to send the funds to the Conditional Splitter and specify a msg to send the received funds based on the splits we have set up earlier.  Now let us represent this message in JSON so we can add it to the web-app:  If you would like to be able to fully test the App and check the results, it is recommended you use the expiration for the timelock to be in around one hour.   Copy {     'hold_funds': {         'condition': {             'expiration':{                 'at_time':1727740799000                 }             },         'recipient':{             'address':'andr1n3nq3aqtjnj40fly76sdt0amjh8aa30drzqcqvt8hapvg7nd4jyq42veq6',             'msg':'eyJzZW5kIjp7fX0='     }   } } The condition part is straight forward. You can use an epoch converter to get the timestamp for end of month in milliseconds.  For the recipient, we specify the address of our Conditional Splitter component for the 'address' field. Here we have to attach a msg along with the recipient. This will instruct the Conditional Splitter what to do when it recieves the funds from the Timelock.   Since we want to split the funds, we use the 'Send' execute message from the list of execute messages for a Conditional Splitter. This will instruct it to send the funds directly to the salesman and company (using the split based on total amount) whenever it receives the funds from the timelock. The msg is specified as Base64 which is the following for a 'Send' execute:  As JSON:  Copy {'send':{}} As Base64:  Copy eyJzZW5kIjp7fX0= So as a quick recap, we did the following:  Tell the marketplace to send the funds from the NFT sales to the Timelock.  Tell the Timelock to hold these funds till the end of the month and to go to the Conditional Splitter when claimed.  Tell the Conditional Splitter to automatically split the funds it receives from the Timelock based on the configurations we set up at creation.   Once done, we can publish. The App has now been successfully set up. You can try buying the NFTs from the marketplace and then claiming these funds from the Timelock using the Release Funds modifier and checking the balances for the salesman and the company before and after claiming. "
	}
]